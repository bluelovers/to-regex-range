"use strict";var e=require("@lazy-assert/check-basic");const t=Symbol.for("SymCache");function toRegexRange(n,r,a){if(!1===e.isUnSafeNumLike(n))throw new TypeError("toRegexRange: expected the first argument to be a number");if(void 0===r||n===r)return String(n);if(!1===e.isUnSafeNumLike(r))throw new TypeError("toRegexRange: expected the second argument to be a number.");n=String(n),r=String(r);let o={relaxZeros:!0,...a};"boolean"==typeof o.strictZeros&&(o.relaxZeros=!1===o.strictZeros);let i=n+":"+r+"="+String(o.relaxZeros)+String(o.shorthand)+String(o.capture)+String(o.wrap);if(toRegexRange[t].hasOwnProperty(i))return toRegexRange[t][i].result;let s=Math.min(n,r),u=Math.max(n,r);if(1===Math.abs(s-u)){let e=n+"|"+r;return o.capture?`(${e})`:!1===o.wrap?e:`(?:${e})`}let g=hasPadding(n)||hasPadding(r),c={min:n,max:r,a:s,b:u},l=[],f=[];return g&&(c.isPadded=g,c.maxLen=String(c.max).length),s<0&&(f=splitToPatterns(u<0?Math.abs(u):1,Math.abs(s),c,o),s=c.a=0),u>=0&&(l=splitToPatterns(s,u,c,o)),c.negatives=f,c.positives=l,c.result=function collatePatterns(e,t,n){let r=filterPatterns(e,t,"-",!1)||[],a=filterPatterns(t,e,"",!1)||[],o=filterPatterns(e,t,"-?",!0)||[];return r.concat(o).concat(a).join("|")}(f,l),!0===o.capture?c.result=`(${c.result})`:!1!==o.wrap&&l.length+f.length>1&&(c.result=`(?:${c.result})`),toRegexRange[t][i]=c,c.result}function rangeToPattern(e,t,n){if(e===t)return{pattern:e,count:[],digits:0};let r=function zip(e,t){let n=[];for(let r=0;r<e.length;r++)n.push([e[r],t[r]]);return n}(e,t),a=r.length,o="",i=0;for(let e=0;e<a;e++){let[t,n]=r[e];t===n?o+=t:"0"!==t||"9"!==n?o+=`[${s=t}${(u=n)-s==1?"":"-"}${u}]`:i++}var s,u;return i&&(o+=!0===n.shorthand?"\\d":"[0-9]"),{pattern:o,count:[i],digits:a}}function splitToPatterns(e,t,n,r){let a,o=function splitToRanges(e,t){let n=1,r=1,a=countNines(e,n),o=new Set([t]);for(;e<=a&&a<=t;)o.add(a),n+=1,a=countNines(e,n);for(a=countZeros(t+1,r)-1;e<a&&a<=t;)o.add(a),r+=1,a=countZeros(t+1,r)-1;return o=[...o],o.sort(compare),o}(e,t),i=[],s=e;for(let e=0;e<o.length;e++){let t=o[e],u=rangeToPattern(String(s),String(t),r),g="";n.isPadded||!a||a.pattern!==u.pattern?(n.isPadded&&(g=padZeros(t,n,r)),u.string=g+u.pattern+toQuantifier(u.count),i.push(u),s=t+1,a=u):(a.count.length>1&&a.count.pop(),a.count.push(u.count[0]),a.string=a.pattern+toQuantifier(a.count),s=t+1)}return i}function filterPatterns(e,t,n,r,a){let o=[];for(let a of e){let{string:e}=a;r||contains(t,"string",e)||o.push(n+e),r&&contains(t,"string",e)&&o.push(n+e)}return o}function compare(e,t){return e>t?1:t>e?-1:0}function contains(e,t,n){return e.some((e=>e[t]===n))}function countNines(e,t){return Number(String(e).slice(0,-t)+"9".repeat(t))}function countZeros(e,t){return e-e%Math.pow(10,t)}function toQuantifier(e){let[t=0,n=""]=e;return n||t>1?`{${t+(n?","+n:"")}}`:""}function hasPadding(e){return/^-?(0+)\d/.test(e)}function padZeros(e,t,n){if(!t.isPadded)return e;let r=Math.abs(t.maxLen-String(e).length),a=!1!==n.relaxZeros;switch(r){case 0:return"";case 1:return a?"0?":"0";case 2:return a?"0{0,2}":"00";default:return a?`0{0,${r}}`:`0{${r}}`}}toRegexRange[t]={},toRegexRange.clearCache=()=>toRegexRange[t]={},Object.defineProperty(toRegexRange,"toRegexRange",{value:toRegexRange}),Object.defineProperty(toRegexRange,"default",{value:toRegexRange}),module.exports=toRegexRange;
//# sourceMappingURL=index.cjs.production.min.cjs.map
